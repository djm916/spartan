(in-package 'spartan.hash-map)

(defstruct __impl (hash equal? table size))

(defun hash-map (hash equal?)
  (def initial-capacity 2)
  (def table (make-vector initial-capacity ()))
  (__impl hash equal? table 0))

(defun hash-map? (self)
  (__impl? self))

(defun empty? (self)
  (= 0 (self 'size)))

(defun size (self)
  (self 'size))

(defun insert! (self key value)
  (def table (self 'table))
  (def capacity (length table))
  (def size (self 'size))
  (def hash (self 'hash))
  (def equal? (self 'equal?))
  (def index (remainder (hash key) capacity))
  (def node (__find-node table equal? index key))
  (if (spartan.core:empty? node)
    ; Key doesn't exist, add new (key, value) pair to bucket
    (let ((node-list (table index))
          (new-node (list key value)))
      (set! (table index) (cons new-node node-list))
      (set! (self 'size) (+ 1 size))
      ; Expand table capacity when load factor exceeded
      (if (> (/ size capacity) 0.75)
        (__resize-to-capacity! self)))
    ; Key exists, replace current value associated with key
    (set-car! (cdr node) value)))

(defun contains? (self key)
  (def table (self 'table))
  (def capacity (length table))
  (def size (self 'size))
  (def hash (self 'hash))
  (def equal? (self 'equal?))
  (def index (remainder (hash key) capacity))
  (def node (__find-node table equal? index key))
  (not (spartan.core:empty? node)))

(defun remove! (self key)
  (def table (self 'table))
  (def capacity (length table))
  (def size (self 'size))
  (def hash (self 'hash))
  (def equal? (self 'equal?))
  (def index (remainder (hash key) capacity))
  (def node-list (table index))
  (defun node-has-key? (node) (equal? key (car node)))
  (set! (table index) (spartan.core:remove! node-has-key? node-list)))
  
(defun find-or-default (self key default)
  (def table (self 'table))
  (def capacity (length table))
  (def size (self 'size))
  (def hash (self 'hash))
  (def equal? (self 'equal?))
  (def index (remainder (hash key) capacity))
  (def node (__find-node table equal? index key))
  (if (spartan.core:empty? node) default (cadr node)))

(defun find (self key)
  (find-or-default self key nil))

(defun for-each (self proc)
  (def table (self 'table))
  (def capacity (length table))
  (def index 0)
  (while (< index capacity)
    (let ((node-list (table index)))
      (while (not (spartan.core:empty? node-list))
        (let ((node (car node-list)))
          (proc (car node) (cadr node))
          (set! node-list (cdr node-list)))))
    (inc! index)))

(defun entries (self)
  (def result ())
  (for-each self 
    (fun (key value)
      (set! result (cons (list key value) result))))
  result)

(defun keys (self)
  (map (fun (pair) (car pair)) (entries self)))

(defun values (self)
  (map (fun (pair) (cadr pair)) (entries self)))

(defun __find-node (table equal? index key)
  (def node-list (table index))
  (def found false)
  (while (and (not found) (not (spartan.core:empty? node-list)))
    (let ((node (car node-list)))
      (if (equal? key (car node))
        (set! found true)
        (set! node-list (cdr node-list)))))
  (if found (car node-list) ()))

(defun __resize-to-capacity! (self)
  (def old-table (self 'table))
  (def old-capacity (length old-table))
  (def new-capacity (* 2 old-capacity))
  (def new-table (make-vector new-capacity ()))
  (set! (self 'table) new-table)
  (set! (self 'size) 0)
  (let ((index 0))
    (while (< index old-capacity)
      (let ((node-list (old-table index)))
        (while (not (spartan.core:empty? node-list))
          (let ((node (car node-list)))
            (insert! self (car node) (cadr node)))
          (set! node-list (cdr node-list))))
      (inc! index))))
